<div align="center"><front size=35>Golang依赖注入框架wire使用详解</front></div>

[toc]

# 1: what is wire

wire 是 google 开源的依赖注入框架。或者引用官方的话来说：“Wire is a code generation tool that automates connecting components using dependency injection.”。

官方地址：https://github.com/google/wire

# 2: Why wire?

除了 wire，Go 的依赖注入框架还有 Uber 的 dig 和 Facebook 的 inject，它们都是使用反射机制来实现运行时依赖注入(runtime dependency injection)，而 wire 则是采用代码生成的方式来达到编译时依赖注入(compile-time dependency injection)。使用反射带来的性能损失倒是其次，更重要的是反射使得代码难以追踪和调试（反射会令 Ctrl+左键失效…）。而 wire 生成的代码是符合程序员常规使用习惯的代码，十分容易理解和调试。
关于 wire 的优点，在官方博文上有更详细的的介绍：blog.golang.org/wire

# 3: provider & injector

- https://blog.csdn.net/uisoul/article/details/108776073
- **provider:** a function that can produce a value. These functions are ordinary Go code.
- **injector:** a function that calls providers in dependency order. With Wire, you write the injector’s signature, then Wire generates the function’s body.
- 通过提供 provider 函数，让 wire 知道如何产生这些依赖对象。wire 根据我们定义的 injector 函数签名，生成完整的 injector 函数，injector 函数是最终我们需要的函数，它将按依赖顺序调用 provider

## 3.1 provider

- provider 就是普通的 Go 函数，可以把它看作是某对象的构造函数，我们通过 provider 告诉 wire 该对象的依赖情况：

```go
// NewUserStore是*UserStore的provider，表明*UserStore依赖于*Config和 *mysql.DB.
func NewUserStore(cfg *Config, db *mysql.DB) (*UserStore, error) {...}

// NewDefaultConfig是*Config的provider，没有依赖
func NewDefaultConfig() *Config {...}

// NewDB是*mysql.DB的provider，依赖于ConnectionInfo
func NewDB(info ConnectionInfo) (*mysql.DB, error) {...}

// UserStoreSet 可选项，可以使用wire.NewSet将通常会一起使用的依赖组合起来。
var UserStoreSet = wire.NewSet(NewUserStore, NewDefaultConfig)

```

## 3.2 injector

- injector 是 wire 生成的函数，我们通过调用 injector 来获取我们所需的对象或值，injector 会按照依赖关系，按顺序调用 provider 函数：

```go
// File: wire_gen.go
// Code generated by Wire. DO NOT EDIT.
//go:generate wire
//+build !wireinject

// initUserStore是由wire生成的injector
func initUserStore(info ConnectionInfo) (*UserStore, error) {
    // *Config的provider函数
    defaultConfig := NewDefaultConfig()
    // *mysql.DB的provider函数
    db, err := NewDB(info)
    if err != nil {
        return nil, err
    }
    // *UserStore的provider函数
    userStore, err := NewUserStore(defaultConfig, db)
    if err != nil {
        return nil, err
    }
    return userStore, nil
}

```

- injector 帮我们把按顺序初始化依赖的步骤给做了，我们在 main.go 中只需要调用 initUserStore 方法就能得到我们想要的对象了。

- 那么 wire 是怎么知道如何生成 injector 的呢？我们需要写一个函数来告诉它：
  - 定义 injector 的函数签名;
  - 在函数中使用 wire.Build 方法列举生成 injector 所需的 provider;

# 4: 实践

## 4.1 install wire

`go install github.com/google/wire/cmd/wire@latest`

## 4.2 quick start

### 4.2.(1) 编写 provider 代价

```go
package provider

type Message struct {
	msg string
}
type Greeter struct {
	Message Message
}
type Event struct {
	Greeter Greeter
}
// NewMessage Message的构造函数
func NewMessage(msg string) Message {
	return Message{
		msg:msg,
	}
}
// NewGreeter Greeter构造函数
func NewGreeter(m Message) Greeter {
	return Greeter{Message: m}
}
// NewEvent Event构造函数
func NewEvent(g Greeter) Event {
	return Event{Greeter: g}
}
func (e Event) Start() {
	msg := e.Greeter.Greet()
	fmt.Println(msg)
}
func (g Greeter) Greet() Message {
	return g.Message
}
```

### 4.2.(2) 编写 main.go，不适用 wire

```go
package main

import (
	"wire-go/provider"
)

// 使用wire前,传统方式
func main() {
	message := provider.NewMessage("hello world")
	greeter := provider.NewGreeter(message)
	event := provider.NewEvent(greeter)

	event.Start()
}


```

### 4.2.(3) 使用 wire 生成 wire_gen.go

- <1> 编写 wire.go
  - wire.go 中定义了 injector 的函数签名，注意要在文件第一行加上`// +build wireinject`;
  - `// +build wireinject`用于告诉编译器无需编译该文件。在 injector 的签名定义函数中，通过调用 wire.Build 方法，指定用于生成依赖的 provider;

```go
// +build wireinject

// The build tag makes sure the stub is not built in the final build.

package main

import (
	"github.com/google/wire"
	"wire-go/provider"
)

// InitializeEvent 声明injector的函数签名
func InitializeEvent(msg string) provider.Event {
	wire.Build(provider.NewEvent, provider.NewGreeter, provider.NewMessage)
	return provider.Event{} //返回值没有实际意义，只需符合函数签名即可
}

```

- <2> 使用`wire`命令生成`wire_gen.go`

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"wire-go/provider"
)

// Injectors from wire.go:

// InitializeEvent 声明injector的函数签名
func InitializeEvent(msg string) provider.Event {
	message := provider.NewMessage(msg)
	greeter := provider.NewGreeter(message)
	event := provider.NewEvent(greeter)
	return event
}

```

- <3> 调用`InitializeEvent`函数，也就是**injector**
  - 在例子中，NewMessage,NewGreeter,NewEvent 都是 provider，wire_gen.go 中的 InitializeEvent 函数是 injector，可以看到 injector 通过按依赖顺序调用 provider 来生成我们需要的对象 Event

## 4.3 高级特性

### 4.3.1 interface 接口绑定

- 根据依赖倒置原则（Dependence Inversion Principle），对象应当依赖于接口，而不是直接依赖于具体实现;

```go
// UserService
type UserService struct {
	userRepo UserRepository // <-- UserService依赖UserRepository接口
}

// UserRepository 存放User对象的数据仓库接口,比如可以是mysql,restful api ....
type UserRepository interface {
	// GetUserByID 根据ID获取User, 如果找不到User返回对应错误信息
	GetUserByID(id int) (*User, error)
}
// NewUserService *UserService构造函数
func NewUserService(userRepo UserRepository) *UserService {
	return &UserService{
		userRepo:userRepo,
	}
}

// mockUserRepo 模拟一个UserRepository实现
type mockUserRepo struct {
	foo string
	bar int
}
// GetUserByID UserRepository接口实现
func (u *mockUserRepo) GetUserByID(id int) (*User,error){
	return &User{}, nil
}
// NewMockUserRepo *mockUserRepo构造函数
func NewMockUserRepo(foo string,bar int) *mockUserRepo {
	return &mockUserRepo{
		foo:foo,
		bar:bar,
	}
}
// MockUserRepoSet 将 *mockUserRepo与UserRepository绑定
var MockUserRepoSet = wire.NewSet(NewMockUserRepo,wire.Bind(new(UserRepository), new(*mockUserRepo)))

```

- 在这个例子中，UserService 依赖 UserRepository 接口，其中 mockUserRepo 是 UserRepository 的一个实现，由于在 Go 的最佳实践中，更推荐返回具体实现而不是接口。所以 mockUserRepo 的 provider 函数返回的是*mockUserRepo 这一具体类型。wire 无法自动将具体实现与接口进行关联，我们需要显示声明它们之间的关联关系。通过 wire.NewSet 和 wire.Bind 将*mockUserRepo 与 UserRepository 进行绑定;

- 定义 Injector 函数签名:

```go
func InitializeUserService(foo string, bar int) *UserService{
	wire.Build(NewUserService,MockUserRepoSet) // 使用MockUserRepoSet
	return nil
}
```

### 4.3.2 组合 provider

- 当一些 provider 通常是一起使用的时候，可以使用 provider set 将它们组织起来;

```go
// EventSet Event通常是一起使用的一个集合，使用wire.NewSet进行组合
var EventSet = wire.NewSet(provider.NewEvent, provider.NewMessage, provider.NewGreeter)

// InitializeEvent 声明injector的函数签名
func InitializeEvent(msg string) provider.Event {
	wire.Build(EventSet) // 组合provider
	return provider.Event{} //返回值没有实际意义，只需符合函数签名即可
}

```

### 4.3.3 结构体 provider

- 除了函数外，结构体也可以充当 provider 的角色，类似于 setter 注入;
- https://github.com/DrmagicE/wire-examples/tree/master/advance-features/struct-provider

### 4.3.4 区分类型

- 由于`injector`的函数中，不允许出现重复的参数类型，否则 wire 将无法区分这些相同的参数类型;
- `provider has multiple parameters of type string`;因为入参均是字符串类型，wire 无法得知入参 a,b 跟 FooBar.foo,FooBar.bar 的对应关系。 所以我们使用不同的类型来避免冲突。

### 4.3.5 Options 结构体

- 如果一个 provider 方法包含了许多依赖，可以将这些依赖放在一个 options 结构体中，从而避免构造函数的参数太多;

```go
type Message string

// Options
type Options struct {
	Messages []Message
	Writer   io.Writer
	Reader   io.Reader
}
type Greeter struct {
}

// NewGreeter Greeter的provider方法使用Options以避免构造函数过长
func NewGreeter(ctx context.Context, opts *Options) (*Greeter, error) {
	return nil, nil
}
// GreeterSet 使用wire.Struct设置Options为provider
var GreeterSet = wire.NewSet(wire.Struct(new(Options), "*"), NewGreeter)

```

- injector 函数签名：

```go
func InitializeGreeter(ctx context.Context, msg []Message, w io.Writer, r io.Reader) (*Greeter, error) {
	wire.Build(GreeterSet)
	return nil, nil
}
```

- https://github.com/DrmagicE/wire-examples/tree/master/best-practice/options-structs

### 4.3.6 error 返回

- 在前面的例子中，我们的 provider 函数均只有一个返回值，但在某些情况下，provider 函数可能会对入参做校验，如果参数错误，则需要返回 error。wire 也考虑了这种情况，provider 函数可以将返回值的第二个参数设置成 error;
- injector 函数定义的时候也需要将第二个返回值设置成 error:

```go
...
func InitializeClient(config Config) (*Service, error) { // <-- 第二个参数设置成error
	wire.Build(NewService,NewAPIClient)
	return nil,nil
}
...
```

- https://github.com/DrmagicE/wire-examples/tree/master/advance-features/return-error

### 4.3.7 clean up

- 当 provider 生成的对象需要一些 cleanup 处理，比如关闭文件，关闭数据库连接等操作时，依然可以通过设置 provider 的返回值来达到这样的效果;

```go
// FileReader
type FileReader struct {
	f *os.File
}
// NewFileReader *FileReader 构造函数，第二个参数是cleanup function
func NewFileReader(filePath string) (*FileReader, func(), error){
	f, err := os.Open(filePath)
	if err != nil {
	    return nil,nil,err
	}
	fr := &FileReader{
	    f:f,
	}
	fn := func() {
	    log.Println("cleanup")
	    fr.f.Close()
	}
	return fr,fn,nil
}

```

- 跟返回错误类似，将 provider 的第二个返回参数设置成 func()用于返回 cleanup function，上述例子中在第三个参数中返回了 error，但这是可选的：
- wire 对 provider 的返回值个数和顺序有所规定：
  - 第一个参数是需要生成的依赖对象;
  - 如果返回 2 个返回值，第二个参数必须是 func()或者 error;
  - 如果返回 3 个返回值，第二个参数必须是 func()，第三个参数则必须是 error;
- https://github.com/DrmagicE/wire-examples/tree/master/advance-features/cleanup-functions
