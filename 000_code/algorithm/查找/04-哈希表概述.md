
- [一 哈希表引入](#一-哈希表引入)
- [二 哈希表概念](#二-哈希表概念)
- [三 Map与Set](#三-map与set)
- [四 哈希值计算](#四-哈希值计算)
  - [4.0 哈希值计算的设计思想](#40-哈希值计算的设计思想)
  - [4.1 直接地址法](#41-直接地址法)
  - [4.2 数字分析法](#42-数字分析法)
  - [4.3 平方取中法](#43-平方取中法)
  - [4.4 折叠法](#44-折叠法)
  - [4.5 除留余数法](#45-除留余数法)
  - [4.6 随机数法](#46-随机数法)

## 一 哈希表引入

下列数据是0-100中任意的5个数据：`17, 31, 6, 42, 15`，现在要查询15是否在该数据中？  

首先我们肯定需要一个容器（一般是数组），将上述元素存储起来形成一个数组`arr=[17,31,6,42,15]`，接着对该数组进行查找，会有很多方法：
- 遍历数组，一一对比，其时间复杂度是O(n)
- 使用二分查找，但是二分查找的前提是有序的，还要对数组进行排序

能不能让时间复杂度立刻变为O(1)?
- 在录入上述5个数据时候，直接这样录入：arr[17]=true, arr[31]=true,arr[6]=true,依次类推
- 当要查找15是否在数据结构中，直接查看 arr[15]的值是否为true即可，这便是哈希的思想    

## 二 哈希表概念

一般来说我们会先设定一个数组，用来存储所有需要存储的数据，然后通过一个函数对key计算得到索引，最后就能通过索引来实现O(1)级别的value查找！ 

> 散列函数：无论给该函数提供什么样的数据，都能返回一个数字，即将输入映射到了数字上。 
> 哈希表：也即散列表，利用数组来存取元素，这样就具备了数组随机存取特性，但是其存取时使用的key并不是数组索引，而是通过散列函数，维护了key与数组索引的映射 

按照这样的要求设计哈希表后，哈希表会具备以下特性：
- 优势：哈希表可以提供快速的插入-删除-查找操作，理想的情况下，其时间复杂度接近O(1)
- 劣势：哈希表中的数据没有顺序，所以不能以一种固定的方式（如从小到大）遍历其中的元素，而且哈希表的key是一般情况下不允许重复

很多语言如Golang，其内部将哈希表的数组称为 Buckets（桶），其元素称为 Bucket，本笔记后续将称呼哈希表的数组为桶。 

## 三 Map与Set

很多编程语言都提供有 `字典 Map结构`，Map的本质上是一个kv对集，我们可以使用很多基本结构来实现，如动态数组、链表、树等。类似Java这样的语言，也提供了多种map的实现，主要的两种现实是：
- TreeMap：底层是红黑树，可以保证键的排序、唯一性，其查找的时间复杂度是O(logn)
- HashMap：就是本章节所说的哈希表，其底层使用位桶、链表实现，HashMap的好处是，在碰撞不发生时，直接能让查找性能到达O(1)（忽略了计算哈希函数的时间消耗）

大多编程语言也会提供 `集合 Set结构` ，用于存储不重复的元素，比如统计网站新增的访问IP。集合的底层数据结构同样可以使用各种基础结构来实现，常见的有：
- TreeSet：底层使用红黑树实现
- HashSet：底层使用哈希表实现

经常会有些面试题：使用Map来实现Set，其实就是只使用Map中的key，而不使用Value，value都为null，这样就能实现Set。  

## 四 哈希值计算

### 4.0 哈希值计算的设计思想

现在我们知道散列函数用于生成哈希值设计要求：
- 快速运算：即我们不但要让这个函数能够将key必定转变为数值，而且该运算的效率必须要高，否则哈希表就失去了快速查询的意义
- 均匀分布：函数返回的结果在哈希表的数组中必须是均匀分布的，因为一旦生成的索引一直在某处集中，不均匀，则会引发哈希表很大的插入问题！

### 4.1 直接地址法

直接地址法不需要散列函数，数据本身就可以作为key而存在。如记录各个年龄人口数，年龄直接可以作为key来使用：
```go
key     value
0       500万
1       1500万
2       2400万
...     ...
100     200万
```
这是最基本的哈希表原理，该方式简单、均匀、无冲突，但是该用法适合于key的数目不多的情况下，否则数组会无限放大。

### 4.2 数字分析法

比如类似手机号这样的数据，都是以13*开头，中间四位表示归属地，最后四位才是真正的用户号，那么最后四个字分布均匀，作为散列地址是很好的选择，或者对这些数据做一些处理后再作为散列地址，比如反转、右环位移（1234改为4123）等。 

### 4.3 平方取中法

假设关键字是1234，其平方为1522756，取其中间三位277，作为散列地址，平方取中法适合不知道关键字的分布，位数不大的情况。 

### 4.4 折叠法

将关键字从左到右分割成位数相等的即部分（最后一部分不足可以短些），然后将几个部分叠加求和，按照散列表表长，取后几位作为散列地址。  

如关键字：9876543210，散列表表长为三位，则可以分为四组987|654|321|0，叠加求和结果987+654+321+0=1962，最后三位962作为散列地址！但是这样可能不能保证均匀分布，可以从一端向另一端来回折叠后对其相加，如987和321反转，再与654、0相加，变成789+654+123+0=1566， 此时散列地址为566。  

折叠法事先不需要知道关键字的分布， 适合关键字位数较多的情况。

### 4.5 除留余数法

除留余数法是最常用的散列函数构造方式：
```
hash(key) = key % p (p <= m)      # m为散列表表长，mod是取模
```

这里的取模可以是在折叠、平方取中后再取模。所以这里需要选择合适的p，p如果选得不好，容易产生碰撞！比如对于关键字12、24、35、48等选择12作为p的值，那么基本全部产生了碰撞，此时选择11则全部不会产生碰撞。  

> 经验： 若散列表表长为m，通常p为小于或等于表长（最好是极度接近m）的最小质数或不包含小于质因子的合数

### 4.6 随机数法

选择一个随机数， 取关键字的随机函数值为它的散列地址。 也就是`f(key)=random(key)`。 这里random是随机函数。 当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。  