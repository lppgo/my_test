- [一 哈希冲突与解决方案](#一-哈希冲突与解决方案)
- [二 链地址法](#二-链地址法)
  - [2.1 装填因子](#21-装填因子)
  - [2.2 链地址法查询效率](#22-链地址法查询效率)
  - [2.3 链地址法的扩容缩容](#23-链地址法的扩容缩容)
  - [2.4 扩容后元素存放](#24-扩容后元素存放)
- [三 开放地址法详解（了解即可）](#三-开放地址法详解了解即可)
  - [3.1 线性探测](#31-线性探测)
  - [3.2 二次探测](#32-二次探测)
  - [3.3 再哈希](#33-再哈希)
  - [3.4 开放地址法总结](#34-开放地址法总结)

## 一 哈希冲突与解决方案

如果两个不同的key，通过哈希函数计算出了相同的哈希值，这时候，哈希表桶中的对应索引位置就会出现多个数据，这种现象称为**哈希碰撞**，也称为**哈希冲突**（Hash Collision）。  

哈希冲突常见的解决办法有两种：
- **链地址法（Separate Chaining）**：桶中的元素都是一个链表，碰撞的元素都存储在链表的节点中
- **开放地址法（Open Addressing）**：发生冲突后，继续寻找哈希表中新的散列地址存放，只要桶足够大，那么空的散列地址一定能找到
- **公共溢出区法**：创建一个与当前哈希表结构一样的哈希表，冲突的数据都放置在该表中，也称呼该表为溢出表。查找时，先与哈希表对照，如果对照不相等，则去溢出表再次查找。在冲突数据较少时，溢出表的性能是非常高的。

贴士：Java采用了链地址法解决哈希碰撞问题，但是在Java8中，如果 `桶的容量 >= 64`，且 `单向链表的节点数 > 8` 时，链表将转换为红黑树，当哈希表不再满足这2个条件时，则红黑树会重新转变为单向链表。  

## 二 链地址法

### 2.1 装填因子

装填因子（Load Factor），也称呼为负载因子，其值为：`节点总数据量 / 哈希表桶长度`。  

装填因子的值与哈希表的查找效率有关。

### 2.2 链地址法查询效率

链地址法实现简单，假设哈希表共计存储数据为n，容量为size，那么平均链表中的元素数目为：n / size，该值即是第二节中的装填因子 Load Factor。  

最坏情况：即是将某个链表的所有元素查询了一遍，次数为：`1 + loadFactor`。  

### 2.3 链地址法的扩容缩容

在使用链地址法时，哈希表虽然可以无限制插入新数据，但是随着数据量的增多，每个index对应的bucket会越来越长，会造成效率的严重降低。  

在合适的情况下就需要对桶进行扩容，Java中扩容的规则：
- 当装填因子超过0.75时，进行扩容：因为装填因子在0.75以下，性能较好
- 容量每次扩大为原来的2倍

注意：如果索引的运算公式使用的是取模，我们说过数组的容量最好是质数，那么此时扩容后也需要保证数组的容量的质数！

### 2.4 扩容后元素存放

扩容后，由于size该不安，对应的index也会改变，那么就需要对所有元素的index和对应的桶重新进行put！！！！。  

注意：扩容会导致计算索引值的时的length出现变化，对应的索引值也会可能出现变化，如果扩容两倍，节点的索引有两种情况：
- 保持不变
- 更改为了 新index = 旧index + 旧容量

一般的做法是遍历以前的节点，将节点直接移动到新的桶中，而不是每个key都要重新创建。  

## 三 开放地址法详解（了解即可）

### 3.1 线性探测

假设有关键字合集：{12,67,56,16,25,37,22,29,15,47,48,34}，表长为12，使用散列函数 `f(key)=key mod 12` 计算索引地址，当计算到37时，会发现与计算25得到的结果都是1，则此时就需要为37寻找新的地址。寻找办法是按照这个公式再次查找 `f(37) = (f(37) + 1) mod 12`，值为2，则将37存入下标为2的位置。依次类推。  

上述的解决方案称为**线性探测**。但是这里还会产生新的问题：在不断+1过程中遇到的位置都不是空位，即是一连串的填充单元！这种现象叫做聚集。聚集引发了严重的性能问题。  

### 3.2 二次探测

针对聚集现象，我们想到的办法自然是优化探测的步长，以减少聚集的机会，例如：第一次探测index+$1^2$，第二次探测index+$2^2$。此种做法我们称为**二次探测**。  

即使是二次探测，也依然会有问题，比如，连续插入的是32-112-82-2-192这样的数据，其累加时步长是相同的，也会造成步长不一样的聚集。  

### 3.3 再哈希

聚集的最终解决方案是**再哈希（Re-Hashing）**，再哈希法是为了彻底消除聚集问题的方案：
- 二次探测的步长是固定的：1，4，9，16....
- 现在使用一种依赖关键字的探测序列，每个关键字都不一样。那么及时不同的关键字映射到了相同的数组下标，其使用的探测序列也不相同

从上看出，再哈希法其实就是把关键字使用另外一个哈希函数，获得的结果作为步长。 

贴士：
- 再哈希函数其结果不能输出为0，因为没有步长则探测变成了原地踏步。
- 再哈希函数也不能和之前的哈希函数一样，因为如果使用一样的哈希函数，其结果还是原来的位置

再哈希函数一般如下表示：
```
# stepSize 即步长。 constant是一个小于数组容量的质数
stepSize = constant - (key % constant)      
```

贴士：利用线性探测时，删除元素操作切记不能将元素设置为空，因为下次探测会遇到空指针，推荐设置为类似-1这样的不可能的值。  

### 3.4 开放地址法总结

开放地址法的效率：发生冲突后取决于探测的长度，平均探测长度取决于装填因子，装填因子越大，探测长度也越大，由于装填因子为：`n / size`， n的最大值只能是size，即装填因子最大值也只能是1。  

探测序列P和装填因子L的关系：
- 查找成功：P = (1 + 1 / (1 - L)$^2$) / 2
- 查找失败：P = (1 + 1 / (1 - L)) / 2

总结：
- 装填因子是1/2时，成功的搜索需要1.5次比较，不成功的搜索需要2.5次
- 装填因子是2/3时，分别需要2.0次和5.0次比较
- 如果装填因子更大，则比较次数会非常大
- 应该使装填因子保持在2/3以下，最好在1/2以下。但是装填因子越低，给定数量的数据项会需要越多的空间
- 实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，速度上升

二次探测和再哈希法性能相当，比线性探测性能略好：
- 成功搜索：-log<sub>2</sub>(1-loadFactor)/loadFactor
- 搜索失败：1/(1-loadFactor)

总结：
- 当填充因子是0.5时，成功和不成功的查找平均需要2次比较
- 当填充因子是2/3时，分别需要2.37和3.0次比较
- 当填充因子是0.8时，分别需要2.9和5.0次
- 因此对于较高的填充因子，相比线性探测，二次探测和再哈希法是可以忍受的