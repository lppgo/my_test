- [1: 红黑树(Red Black Tree)](#1-红黑树red-black-tree)
  - [1.1 rbTree的特性](#11-rbtree的特性)
- [2: 红黑树的基本操作](#2-红黑树的基本操作)
  - [2.1 插入与删除的说明](#21-插入与删除的说明)
  - [2.2 插入节点](#22-插入节点)
  - [2.3 go实现红黑树简单结构](#23-go实现红黑树简单结构)


# 1: 红黑树(Red Black Tree)
**红黑树**是一种自平衡二叉搜索树
![](https://i.bmp.ovh/imgs/2021/04/520f720fe1eb0601.png)

## 1.1 rbTree的特性
1. 节点是红色或者黑色;
2. 根节点是黑色;
3. 叶节点是黑色空节点，叶子节点不存储值;
4. 红色节点的子节点都是黑色，也意味着从叶节点到根节点的所有路径上，不存在2个连续的红色节点;
5. 从任意节点开始，到达每个叶子节点的路径中，都具有相同数量的黑色节点;


红黑树与四阶B树具有等价性质，红黑树可以变形为类似四阶B树的样子:

# 2: 红黑树的基本操作

## 2.1 插入与删除的说明
红黑树不强调AVL树的平衡因子概念，插入和删除需要考虑的是是否符合红黑树的5个性质。

## 2.2 插入节点
插入的节点默认都是红色，因为如果是黑色，必然会导致一条路径上多了黑色节点，违反了上面的性质5,调整难度较大；
如果插入的是节点默认是红色，就直接满足红黑树的5个性质，即使出现了红红相连的情况，也可通过颜色调换来进行调整。

**建造树**，然后便建造便分析各种情况。
- 父亲节点为黑直接加入即可
- 父亲叔叔节点为红，将爷爷变红，父亲叔叔变黑直接加入，如果爷爷为根节点则不需要改变颜色
- 父亲为红叔叔为黑，分2种情况
  - 1. 父亲为左子树自己也是左子树或者父亲为右子树自己也为右子树，父亲变黑爷爷变红，自己为左子树右旋转，自己为右子树左旋转
  - 2. 父亲为左子树自己是右子树或者父亲为右子树自己也为左子树，先和父亲替换下位置然后以父亲为新加入的节点进行变化


## 2.3 go实现红黑树简单结构
```go
const (
    // RED 红树设为true
    RED bool = true
    // BLACK 黑树设为false
    BLACK bool = false
)

// RBNode 红黑树
type RBNode struct {
    value               int64
    color               bool
    left, right, parent *RBNode
}
// 
type RBTree struct {
    root *RBNode
}

// getGrandParent() 获取父级节点的父级节点
func (rbnode *RBNode) getGrandParent() *RBNode {'...'}

// getSibling() 获取兄弟节点
func (rbnode *RBNode) getSibling() *RBNode {'...'}

// GetUncle() 父节点的兄弟节点
func (rbnode *RBNode) getUncle() *RBNode {'...'}
```