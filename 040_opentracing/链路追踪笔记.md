[toc]

# 1: 链路追踪 Introduction

- 开发和工程团队因为系统组件水平扩展、开发团队小型化、敏捷开发、CD（持续集成）、解耦等各种需求，软件系统架构由单体应用发展成微服务架构成为主流。 也就是说，当一个系统面对真正的高并发，或者解耦成大量微服务时，以前很容易实现的重点任务(服务组织管理，服务调用监控等)变得困难了。过程中需要面临一系列问题：用户体验优化、错误原因分析，分布式系统内各组件的调用情况分析等。 当代分布式跟踪系统（例如，Zipkin, Dapper, HTrace, X-Trace 等）旨在解决这些问题。

- 微服务架构下，服务按照不同的维度进行拆分，一次请求请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心。因此，就需要一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题。

- 随着微服务架构的流行，请求涉及的调用链异常复杂，引入链路追踪组件便于排查分析问题。
- 目前大多数分布式追踪系统的思想模型都来自 2010 年 Google's Dapper 论文。
- [Dapper, a Large-Scale Distributed Systems Tracing Infrastructure](http://bigbully.github.io/Dapper-translation/)。

# 2：链路追踪的现有的产品

## 2.1 未开源

- (1) **Dapper** (Google): 最早的 APM 组件 (Application Performance Management);
- (2) **EagleEye** (阿里):
- (3) **CAT** (大众点评): 跨服务的跟踪功能与点评内部的 RPC 框架集成 2014.1 已停止维护。
- (4) **Hydra** (京东): 与 dubbo 集成，服务级别的跟踪统计，2013.6 停止维护。

## 2.2 开源

## 2.1 PinPoint

- (韩国) 支持 dubbo 技术栈。
- https://github.com/pinpoint-apm/pinpoint

## 2.2 Zipkin

- (Twitter) 支持 spring cloud,dubbo,raabit ,http 等；
- 支持 php,go js 等语言的客户端,功能界面较为简单。
- https://github.com/openzipkin/zipkin/

## 2.3 Jaeger

- (Uber) 支持 java/c++/go/php/node 等语言，在界面上较 Zipkin 完善；
- https://www.jaegertracing.io/

## 2.4 Skywalking

- (华为) java 开发，提供了 Go, C++ SDKs.
- http://skywalking.apache.org/

## 2.5 LightStep

- 公司由前 Google 工程师 Ben Sigelman 于 2015 年成立（创始人曾经是`Dapper`的开发者，专注于分布式链路追踪），LightStep 的使命是削减软件的规模和复杂性，帮助公司能够持续保持对其系统的控制。第一个产品 LightStep [x]PM 能够在任何时间点提供整个软件系统准确、详细的快照，基于快照能够快速识别问题、瓶颈并解决。
- LightStep 支持主流语言的 Trace 接入，并且一些库(Java,NodeJs 等)中还带有一些 Metric 的接入方式。
- 遵循**OpenTracing**、[**OpenTelemetry**](https://opentelemetry.io/docs/concepts/what-is-opentelemetry/)标准来提供服务
- github.com/lightstep/lightstep-tracer-go

## 2.6 使用 jmeter 对这些 APM 组件进行测试

- http://blueskykong.com/2017/12/05/apm2/

![](http://blueskykong.com/pic/apm-compare.jpg)

# 3：链路追踪的核心与标准

## 3.1 链路追踪的核心思想

- 为每条请求都单独分配一个唯一的 `traceId` 用来标识一条请求链路，该 traceId 会贯穿整个请求处理过程的所有服务。
- 每个服务/线程都拥有自己的 `spanId` 标识，代表请求的其中一段处理步骤。
- 一个请求包含一个 `traceId` 和一个或多个 `spanId`。

![](https://img2020.cnblogs.com/blog/1577453/202103/1577453-20210303171010383-2138452589.png)

## 3.2 OpenTracing Semantic Specification 语义规范

- https://opentracing.io/
- [Semantic Specification](https://opentracing.io/specification/)
- `OpenTracing`通过提供与平台无关，厂商无关的 API,使得开发人员灵活方便的添加与更换追踪系统的实现。
- 在分布式链路跟踪中有两个重要的概念：跟踪（**trace**）和 跨度（ **span**）。`trace` 是请求在分布式系统中的整个链路视图，`span` 则代表整个链路中不同服务内部的视图，span 组合在一起就是整个 trace 的视图。
- **Trace** 一个trace代表一个潜在的，分布式的，存在并行数据或并行执行轨迹（潜在的分布式、并行）的系统。一个trace可以认为是多个span的有向无环图（DAG）.
- **Span** 一个span代表系统中具有开始时间和执行时长的逻辑运行单元。span之间通过嵌套或者顺序排列建立逻辑因果关系。
- 每一个**span**封装了以下状态:
  - An operation name (操作名称)
  - A start timestamp (开始时间戳)
  - A finish timestamp (完成时间戳)
  - **span tags** A set of zero or more key:value。The keys must be strings. The values may be strings, bools, or numeric types.
  - **span logs** A set of zero or more Span Logs, each of which is itself a key:value map paired with a timestamp. The keys must be strings, though the values may be of any type.
  - **SpanContext** 每个 SpanContext 封装了以下状态：
    - (1) 任何依赖 OpenTracing 实现的状态（例如，trace 和 span id）需要跨进程边界引用不同的 Span
    - (2) **Baggage Items**, which are just key:value pairs that cross process boundaries
  - **References** to zero or more causally-related Spans (via the SpanContext of those related Spans)
- span 之间的 reference 引用关系。Span 可以引用零个或多个其他因果相关的 SpanContext。
  - (1) **ChildOf** 一个 Span 可以是另一个 Span 的子 Span。在 ChildOf 引用中，父 Span 在某种程度上取决于子 Span。下列情况会构成 ChildOf 关系:
    - <1> 在一个 RPC 中，代表服务端的 Span 可作为 ChildOf 代表客户端的 Span;
    - <2> 在一个持久化进程中，代表 SQL 插入的 Span 可作为 ChildOf 代表 ORM save 方法的 Span;
    - <3> 多个并发(可能是分布式)执行任务的 Span 可能分别各自为 Childof 一个合并了多个子 Span 结果的父 Span;
  - (2) **FollowsFrom** 一些父级 span 不以任何方式依赖于他们的子级 span 的结果。

## 3.3 The OpenTracing API

### 3.3.1 Tracer

- **Tracer**接口创建 Spans 并且能够跨进程的**Inject(serialize)** 和 **Extract(deseriable)**。形式上具有以下功能:
  - `start a new span`
  - `Inject a SpanContext from a carrier` 将 SpanCtx 注入 carrier 载体
  - `Extrace a SpanContext from a carrier` 从 carrier 提取 SpanCtx

### 3.3.2 Span

- Retrieve the Spans SpanContext
- Overwrite the operation name
- Finish the Span
- Set a Span tag
- Log structured data
- Set a baggage item
- Get a baggage item

```go
  // Start a new root span.
  sp := opentracing.StartSpan("GET /home")
  defer sp.Finish()

  // Inject
  err:=sp.Tracer().Inject(sp.Context(), opentracing.TextMap, opentracing.HTTPHeadersCarrier(asyncReq.Header))

  // 子span调用
  {
     var sp opentracing.Span
     spCtx, err := opentracing.GlobalTracer().Extract(opentracing.TextMap, opentracing.HTTPHeadersCarrier(r.Header))
     if err == nil {
  	    sp = opentracing.StartSpan(opName, opentracing.ChildOf(spCtx))
     } else {
  	    sp = opentracing.StartSpan(opName)
     }
     defer sp.Finish()
  }

  // 子span返回
    //  Tag the span as errored
  	ext.Error.Set(sp, true)
  	//  Log the span as errored
  	sp.LogFields(openLog.String("Get asyncReq error", err.Error()))
```

### 3.3.3 SpanContext

### 3.3.4 NoopTracer

- 所有语言的 OpenTracing API 必须提供某种 NoopTracer 实现，可用作标记控制(flag-control)或者进行一些用于测试的无害注入等。

### 3.3.3 Optional API Elements

- 可选的 API 元素

# 4：Example
